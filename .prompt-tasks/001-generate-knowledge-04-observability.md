# 任务：生成可观测性知识文档

## 目标
为指定的技术栈/项目创建全面的可观测性文档，详细介绍监控、日志、链路追踪、指标收集等观测能力的配置和使用，帮助用户构建完整的系统可观测性体系。

## 任务执行要求

### 1. 目录结构
```
{project}/knowledge/04-observability/
├── README.md                     # 可观测性总览和索引
├── metrics.md                    # 指标监控
├── logging.md                    # 日志管理
├── tracing.md                    # 链路追踪
├── alerting.md                   # 告警机制
├── dashboards.md                 # 仪表板配置
├── troubleshooting.md            # 故障诊断
└── best-practices.md             # 最佳实践
```

**强制要求按类型拆分文件的原则：**
- **强制拆分**：必须按照可观测性的不同类型创建独立文件，不允许合并
- **类型维度**：严格按照指标、日志、链路追踪、告警等类型维度拆分
- **文件专一性**：每个文件只能专注于单一类型的可观测性内容
- **完整覆盖**：必须覆盖所有主要的可观测性类型，不得遗漏
- **标准命名**：使用标准的文件名，不允许自定义命名

### 2. README.md 必须包含的内容结构

#### 2.1 可观测性概述
- **可观测性定义**：什么是可观测性及其重要性
- **三大支柱**：指标（Metrics）、日志（Logs）、链路追踪（Traces）
- **技术架构**：可观测性技术栈的整体架构
- **价值体现**：可观测性为业务和技术带来的价值

#### 2.2 可观测性架构图
```markdown
## 可观测性架构

使用 Mermaid 展示完整的可观测性架构：

### 数据收集层
- 指标收集器（Prometheus、Grafana Agent等）
- 日志收集器（Fluentd、Filebeat等）
- 链路追踪收集器（Jaeger、Zipkin等）
- 自定义探针和采集器

### 数据存储层
- 时序数据库（Prometheus、InfluxDB、M3等）
- 日志存储（Elasticsearch、Loki等）
- 链路追踪存储（Jaeger、Zipkin等）
- 长期存储和归档策略

### 数据分析层
- 查询引擎（PromQL、LogQL等）
- 数据聚合和计算
- 异常检测和模式识别
- 自动化分析工具

### 可视化层
- 仪表板（Grafana、Kibana等）
- 告警系统（Alertmanager等）
- 报表系统
- 自定义可视化组件
```

#### 2.3 可观测性能力矩阵
创建可观测性能力索引表格，包含：
- 观测维度（基础设施/应用/业务）
- 数据类型（指标/日志/链路）
- 收集方式（推送/拉取/代理）
- 存储方案
- 查询能力
- 告警配置
- 详细文档链接

#### 2.4 关键观测场景
- **性能监控**：应用和系统性能的实时监控
- **错误追踪**：错误发生、传播和影响的追踪
- **容量规划**：基于历史数据的容量预测和规划
- **SLA监控**：服务等级协议的监控和报告
- **安全监控**：安全事件和异常行为的检测

### 3. 各观测能力文档的标准结构

#### 3.1 指标监控（metrics.md）
```markdown
# 指标监控

## 指标体系设计

### 基础设施指标
- **系统指标**：CPU、内存、磁盘、网络等
- **容器指标**：Docker、Kubernetes资源使用情况
- **中间件指标**：数据库、缓存、消息队列等性能指标

### 应用指标
- **性能指标**：响应时间、吞吐量、并发数等
- **业务指标**：用户行为、交易量、转化率等
- **错误指标**：错误率、异常数量、失败类型等

### 自定义指标
- **业务KPI**：关键业务指标的定义和收集
- **技术KPI**：技术质量指标的监控
- **SLA指标**：服务等级协议相关指标

## 指标收集配置

### Prometheus配置
提供完整的Prometheus配置示例：
- **采集配置**：各种服务的指标采集配置
- **存储配置**：数据保留策略和存储优化
- **规则配置**：告警规则和记录规则
- **服务发现**：动态服务发现配置

### 指标暴露
- **应用埋点**：在应用中暴露自定义指标
- **Exporter使用**：各种系统和服务的Exporter配置
- **指标格式**：Prometheus指标格式规范
- **标签设计**：高基数标签的处理策略

## 查询和分析

### PromQL使用
- **基础查询**：常用的PromQL查询语法
- **聚合函数**：数据聚合和计算方法
- **时间序列操作**：时间窗口和趋势分析
- **高级查询**：复杂业务场景的查询实现

### 性能优化
- **查询优化**：提高查询性能的策略
- **存储优化**：降低存储成本的方法
- **采集优化**：减少采集开销的技巧
- **扩展性设计**：大规模部署的架构考虑
```

#### 3.2 日志管理（logging.md）
```markdown
# 日志管理

## 日志架构设计

### 日志分类
- **系统日志**：操作系统和基础设施日志
- **应用日志**：应用程序业务和错误日志
- **访问日志**：Web服务器和API访问日志
- **审计日志**：安全和合规相关的审计记录

### 日志标准化
- **日志格式**：结构化日志格式规范（JSON、logfmt等）
- **日志级别**：日志级别的定义和使用原则
- **日志字段**：标准日志字段的定义和规范
- **时间戳**：统一的时间戳格式和时区处理

## 日志收集和传输

### 收集器配置
- **Fluentd配置**：日志收集和路由配置
- **Filebeat配置**：轻量级日志收集器配置
- **Vector配置**：高性能日志处理配置
- **自定义收集器**：特殊场景的日志收集方案

### 传输优化
- **批量传输**：提高传输效率的批量处理
- **压缩传输**：减少网络带宽的压缩策略
- **缓冲机制**：处理传输延迟和网络抖动
- **错误处理**：传输失败的重试和恢复机制

## 日志存储和索引

### 存储方案
- **Elasticsearch**：全文搜索和分析引擎配置
- **Loki**：轻量级日志聚合系统
- **ClickHouse**：高性能列式数据库存储
- **对象存储**：长期归档和冷数据存储

### 索引策略
- **索引设计**：高效的索引策略和字段选择
- **分片管理**：数据分片和副本配置
- **生命周期管理**：数据保留和清理策略
- **性能调优**：查询和写入性能优化

## 日志查询和分析

### 查询语言
- **Lucene查询**：Elasticsearch查询语法
- **LogQL**：Loki查询语言使用
- **SQL查询**：结构化查询语言支持
- **正则表达式**：复杂模式匹配和提取

### 日志分析
- **错误分析**：错误日志的聚合和分析
- **性能分析**：基于访问日志的性能分析
- **用户行为分析**：用户操作路径和行为分析
- **安全分析**：安全威胁和异常行为检测
```

#### 3.3 链路追踪（tracing.md）
```markdown
# 链路追踪

## 分布式追踪原理

### 追踪概念
- **Trace**：完整的请求调用链路
- **Span**：单个操作或服务调用
- **上下文传播**：跨服务的追踪上下文传递
- **采样策略**：减少性能开销的采样机制

### 追踪标准
- **OpenTracing**：追踪API标准规范
- **OpenTelemetry**：统一的可观测性框架
- **Jaeger追踪**：分布式追踪系统使用
- **Zipkin追踪**：轻量级追踪系统配置

## 追踪实现和配置

### 应用埋点
- **自动埋点**：框架和中间件的自动追踪
- **手动埋点**：业务代码的手动追踪配置
- **异步追踪**：异步操作的追踪处理
- **数据库追踪**：数据库操作的追踪配置

### 追踪传播
- **HTTP传播**：HTTP请求的追踪上下文传播
- **消息队列传播**：异步消息的追踪传播
- **gRPC传播**：gRPC调用的追踪传播
- **自定义传播**：特殊协议的追踪传播实现

## 追踪数据分析

### 性能分析
- **调用链分析**：请求在各服务间的调用关系
- **延迟分析**：请求处理时间的分解和分析
- **瓶颈识别**：系统性能瓶颈的定位
- **依赖分析**：服务间依赖关系的可视化

### 错误追踪
- **错误传播**：错误在调用链中的传播路径
- **根因分析**：错误根本原因的定位
- **影响范围**：错误影响的服务和用户范围
- **恢复策略**：基于追踪数据的故障恢复
```

#### 3.4 告警机制（alerting.md）
```markdown
# 告警机制

## 告警策略设计

### 告警分级
- **P0告警**：影响核心业务的紧急告警
- **P1告警**：影响重要功能的高优先级告警
- **P2告警**：一般性问题的中优先级告警
- **P3告警**：优化建议的低优先级告警

### 告警规则
- **阈值告警**：基于固定阈值的告警配置
- **趋势告警**：基于趋势变化的告警检测
- **异常告警**：基于机器学习的异常检测
- **复合告警**：多条件组合的复杂告警规则

## 告警配置和管理

### Alertmanager配置
- **路由配置**：告警路由和分发规则
- **抑制配置**：告警抑制和降噪策略
- **静默配置**：临时静默和维护窗口
- **接收器配置**：多种告警通知渠道

### 告警通知
- **邮件通知**：邮件告警的配置和模板
- **即时消息**：Slack、钉钉等即时通知
- **短信通知**：紧急情况的短信告警
- **电话通知**：最高级别的电话告警

### 告警响应
- **值班机制**：告警值班和轮换制度
- **升级机制**：告警升级和上报流程
- **处理流程**：标准化的告警处理流程
- **反馈机制**：告警处理结果的反馈和记录
```

### 4. 文档质量要求

#### 4.1 实用性要求
- **配置完整**：提供完整可用的配置示例
- **步骤清晰**：详细的部署和配置步骤
- **问题解决**：常见问题的解决方案
- **最佳实践**：生产环境的最佳实践指导

#### 4.2 技术准确性
- **版本一致**：与当前技术版本保持一致
- **配置正确**：所有配置示例经过验证
- **命令准确**：所有命令和脚本可以直接执行
- **链接有效**：所有外部链接和引用有效可访问

#### 4.3 可维护性
- **模块化设计**：文档结构清晰，易于维护
- **版本控制**：文档版本和技术版本的对应关系
- **更新机制**：定期更新和维护的机制
- **社区贡献**：支持社区贡献和反馈的机制

### 5. 执行步骤

1. **需求分析**：分析目标技术的可观测性需求和场景
2. **架构设计**：设计完整的可观测性技术架构
3. **类型拆分**：按照可观测性类型强制拆分文档文件
4. **工具选型**：选择合适的监控、日志和追踪工具
5. **配置开发**：开发各种工具的配置和集成方案
6. **测试验证**：在测试环境验证所有配置的正确性
7. **文档编写**：按标准结构编写详细的配置文档
8. **最佳实践**：总结生产环境的最佳实践经验
9. **持续优化**：根据使用反馈持续优化和改进

### 6. 输出验证

完成后的可观测性文档应能够：
- 帮助团队快速搭建完整的监控体系
- 提供生产就绪的配置和部署方案
- 支持故障快速发现、定位和解决
- 为系统优化和容量规划提供数据支持
- 满足合规和审计的要求
- 提升团队的运维效率和系统可靠性

## 适用范围

此任务模板适用于需要建立可观测性体系的各种技术和场景，包括：
- 微服务架构的全链路监控
- 云原生应用的可观测性
- 容器和Kubernetes集群监控
- 分布式系统的性能监控
- 大规模系统的运维监控
- 业务系统的健康状态监控
- 安全监控和合规审计
- 任何需要全面监控和观测的技术系统
